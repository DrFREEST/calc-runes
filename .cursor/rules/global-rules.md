# ============================================================================

# 🌐 GLOBAL DEVELOPMENT RULES - 글로벌 개발 규칙

# ============================================================================

# 작성일: 2025-11-26

# 목적: 모든 프로젝트에 범용적으로 적용 가능한 개발 규칙 정의

# 적용범위: 언어/프레임워크에 관계없이 전역 적용

# ============================================================================

# ============================================================================

# 📌 섹션 1: 클린 코드 원칙 (Clean Code Principles)

# ============================================================================

## 1.1 SOLID 원칙

- **S (Single Responsibility)**: 하나의 클래스/함수는 하나의 책임만 가짐
- **O (Open/Closed)**: 확장에는 열려있고, 수정에는 닫혀있어야 함
- **L (Liskov Substitution)**: 하위 타입은 상위 타입을 대체할 수 있어야 함
- **I (Interface Segregation)**: 클라이언트가 사용하지 않는 인터페이스에 의존하지 않음
- **D (Dependency Inversion)**: 고수준 모듈이 저수준 모듈에 의존하지 않음

## 1.2 DRY (Don't Repeat Yourself)

- 동일한 코드가 2회 이상 반복되면 함수/모듈로 추출
- 유사도 50% 이상인 코드는 공통 로직으로 통합 검토
- 복사-붙여넣기 코딩 금지

## 1.3 KISS (Keep It Simple, Stupid)

- 불필요한 복잡성 추가 금지
- 간단한 해결책이 있으면 복잡한 방법 사용 금지
- 코드는 읽기 쉽게 작성 (작성보다 읽는 횟수가 훨씬 많음)

## 1.4 YAGNI (You Aren't Gonna Need It)

- 현재 필요하지 않은 기능 미리 구현 금지
- "나중에 필요할 것 같다"는 이유로 코드 추가 금지
- 요구사항에 명시된 기능만 구현

# ============================================================================

# 📌 섹션 2: 방어적 프로그래밍 및 에러 처리

# ============================================================================

## 2.1 방어적 프로그래밍 원칙

- 모든 외부 입력값은 신뢰하지 않고 검증
- 함수 진입점에서 파라미터 유효성 검사 (Guard Clause 패턴)
- null/undefined 반환보다 빈 배열 [], 빈 객체 {} 반환 선호
- 실패할 수 있는 모든 작업에 에러 처리 구현

## 2.2 Guard Clause 패턴

- 함수 시작 부분에서 유효하지 않은 조건을 먼저 처리하고 조기 반환
- 중첩 if문 최소화로 가독성 향상
- 예시:
  ```
  function process(data) {
    if (!data) return null;           // Guard Clause
    if (!data.id) return null;        // Guard Clause
    // 메인 로직
  }
  ```

## 2.3 에러 처리 표준

- 에러 메시지 구성: [위치][원인][해결방법]
- 사용자용 메시지와 개발자용 로그 분리
- 에러 전파 시 원본 에러 정보(stack trace) 보존
- 복구 가능한 에러 vs 치명적 에러 구분 처리

## 2.4 비동기 에러 처리

- 모든 async 함수에 try-catch 적용 필수
- Promise 체인에서 .catch() 누락 금지
- unhandledRejection 방지

# ============================================================================

# 📌 섹션 3: 보안 규칙 (Security Rules)

# ============================================================================

## 3.1 입력 검증 규칙

- 모든 사용자 입력은 화이트리스트 방식으로 검증
- 정규식 검증 시 ReDoS 공격 방지 패턴 사용
- 파일 업로드: 확장자 + MIME 타입 + 파일 크기 모두 검증
- 숫자 입력: 범위(min/max) 검증 필수

## 3.2 출력 이스케이프 규칙

- HTML 출력 시 XSS 방지 이스케이프 필수
- SQL 쿼리는 반드시 파라미터 바인딩 사용 (SQL Injection 방지)
- URL 파라미터 사용 시 인코딩 필수
- JSON 응답 시 Content-Type 헤더 명시

## 3.3 민감 정보 보호

- API 키, 비밀번호, 토큰 등 소스코드에 직접 작성 절대 금지
- 환경 변수 또는 별도 설정 파일로 관리
- 로그에 민감 정보 출력 금지 (마스킹 처리)
- 에러 메시지에 시스템 내부 정보(DB 구조, 파일 경로 등) 노출 금지

## 3.4 인증/인가 규칙

- 모든 보호된 리소스 접근 시 권한 검증 필수
- 세션/토큰 만료 처리 필수
- CSRF 토큰 검증 적용

# ============================================================================

# 📌 섹션 4: 성능 최적화 규칙 (Performance Rules)

# ============================================================================

## 4.1 리소스 관리

- 사용 완료된 리소스는 즉시 해제:
  - 이벤트 리스너 제거
  - 타이머(setInterval, setTimeout) 정리
  - 데이터베이스 커넥션 반환
- 메모리 누수 방지를 위한 참조 해제

## 4.2 연산 최적화

- 반복문 내 불변값은 외부에서 미리 계산
- 캐싱 가능한 데이터는 적극 캐싱 (메모이제이션)
- 비용이 큰 연산은 debounce/throttle 적용
- 불필요한 연산 제거

## 4.3 데이터 처리 최적화

- 대용량 데이터는 페이지네이션/무한 스크롤 적용
- 필요한 데이터만 요청 (over-fetching 방지)
- 배치 처리 가능한 작업은 일괄 처리

## 4.4 DOM 최적화 (프론트엔드)

- DOM 접근 최소화 (쿼리 결과 변수에 캐싱)
- 일괄 DOM 변경 시 DocumentFragment 사용
- 강제 리플로우 유발 속성 연속 접근 금지:
  - offsetWidth, offsetHeight, clientWidth, scrollTop 등
- 이벤트 위임(Event Delegation) 적극 활용

## 4.5 네트워크 최적화

- 이미지/미디어 lazy loading 적용
- 리소스 압축(gzip, minify) 적용
- 불필요한 API 호출 제거
- 동일 요청 중복 방지

# ============================================================================

# 📌 섹션 5: 네이밍 컨벤션 (Naming Convention)

# ============================================================================

## 5.1 범용 네이밍 원칙

- 변수/함수명은 의도를 명확하게 표현
- 축약어 사용 지양 (단, 널리 알려진 약어는 허용: id, url, html 등)
- 검색 가능한 이름 사용 (한 글자 변수 지양)

## 5.2 변수 네이밍

- 일반 변수: camelCase (예: userName, totalCount)
- 상수: UPPER_SNAKE_CASE (예: MAX_RETRY_COUNT, API_BASE_URL)
- Boolean 변수: is/has/can/should prefix
  - isLoading, hasError, canSubmit, shouldUpdate

## 5.3 함수 네이밍

- 동사로 시작 (액션을 표현)
- 일반 함수: camelCase
- 주요 동사 prefix:
  - get/fetch: 데이터 조회
  - set/update: 데이터 수정
  - create/add: 데이터 생성
  - delete/remove: 데이터 삭제
  - validate/check: 검증
  - handle/on: 이벤트 처리
  - render/display: 화면 표시
  - init/setup: 초기화

## 5.4 클래스/생성자 네이밍

- PascalCase 사용 (예: UserManager, BannerEditor)
- 명사 또는 명사구 사용
- 역할을 명확히 표현

## 5.5 금지 네이밍

- 한 글자 변수 (반복문 i, j, k 제외)
- 의미없는 이름 단독 사용: data, info, temp, result, item
- 오해 유발 이름: list가 아닌데 xxxList, 배열 아닌데 xxxArray
- 타입을 이름에 포함 (헝가리안 표기법 지양): strName, intCount

# ============================================================================

# 📌 섹션 6: 비동기 처리 규칙 (Async Rules)

# ============================================================================

## 6.1 비동기 코드 표준

- Promise 체인보다 async/await 선호 (가독성)
- 모든 async 함수에 try-catch 적용
- 에러 발생 시 적절한 처리 또는 상위로 전파

## 6.2 병렬 처리 최적화

- 독립적인 비동기 작업은 Promise.all()로 병렬 처리
- 순차 처리가 필요한 경우에만 await 연속 사용
- Promise.allSettled(): 일부 실패해도 전체 결과 필요 시

## 6.3 타임아웃 및 취소

- 모든 네트워크 요청에 타임아웃 설정 필수
- 무한 대기 방지
- 필요 시 요청 취소 로직 구현 (AbortController 등)

## 6.4 동시성 제어

- 중복 요청 방지 (debounce, 플래그 사용)
- Race Condition 방지:
  - 요청 ID로 최신 응답만 처리
  - 이전 요청 취소
- 순서 보장 필요 시 큐 패턴 사용

# ============================================================================

# 📌 섹션 7: 테스트 가능한 코드 작성 (Testable Code)

# ============================================================================

## 7.1 테스트 용이성 설계

- 함수는 가능한 순수 함수로 작성 (동일 입력 → 동일 출력)
- 외부 의존성(API, DB, 시간 등)은 주입 가능하도록 설계
- 전역 상태 사용 최소화
- 하드코딩된 값은 상수 또는 설정으로 분리

## 7.2 함수 설계 원칙

- 함수는 한 가지 일만 수행 (Single Responsibility)
- 적절한 크기 유지 (일반적으로 20~30줄 이내 권장)
- 부수 효과(Side Effect) 최소화

## 7.3 테스트 작성 규칙

- 경계값 테스트 필수: 0, null, undefined, 빈 값, 최대값
- 성공 케이스와 실패 케이스 모두 테스트
- 테스트는 독립적으로 실행 가능해야 함 (다른 테스트에 의존 금지)
- 테스트 이름은 의도를 명확히 표현

# ============================================================================

# 📌 섹션 8: 코드 리뷰 체크리스트 (Code Review Checklist)

# ============================================================================

## 8.1 기능 검증

- [ ] 요구사항을 정확히 구현했는가?
- [ ] 기존 기능에 영향(사이드 이펙트)은 없는가?
- [ ] 엣지 케이스 처리가 되어있는가?

## 8.2 코드 품질

- [ ] 코드 중복은 없는가?
- [ ] 네이밍이 명확하고 일관성 있는가?
- [ ] 함수/클래스가 단일 책임을 가지는가?
- [ ] 불필요한 복잡성은 없는가?

## 8.3 에러 처리

- [ ] 에러 처리가 적절한가?
- [ ] 사용자에게 적절한 피드백을 제공하는가?
- [ ] 예외 상황에서 시스템이 안정적인가?

## 8.4 보안

- [ ] 입력값 검증이 되어있는가?
- [ ] 민감 정보 노출은 없는가?
- [ ] XSS, SQL Injection 등 취약점은 없는가?

## 8.5 성능

- [ ] 성능 저하 요소는 없는가?
- [ ] 불필요한 연산/호출은 없는가?
- [ ] 리소스 해제가 적절히 되어있는가?

## 8.6 문서화

- [ ] 주석은 충분하고 명확한가?
- [ ] 복잡한 로직에 설명이 있는가?
- [ ] API 문서가 업데이트되었는가?

# ============================================================================

# 📌 섹션 9: 커밋 및 버전 관리 (Version Control)

# ============================================================================

## 9.1 커밋 규칙 (CRITICAL!)

- ⚠️ **자동 커밋/푸시 절대 금지**
- ⚠️ **커밋 메시지 제안까지만 수행**
- 실제 커밋 및 푸시는 개발자가 직접 수행

## 9.2 커밋 메시지 컨벤션 (제안용)

- 형식: `[타입] 제목 (50자 이내)`
- 타입 종류:
  - `feat`: 새로운 기능 추가
  - `fix`: 버그 수정
  - `refactor`: 코드 리팩토링 (기능 변경 없음)
  - `style`: 코드 포맷팅, 세미콜론 누락 등 (기능 변경 없음)
  - `docs`: 문서 수정
  - `test`: 테스트 코드 추가/수정
  - `chore`: 빌드, 설정 파일 수정

## 9.3 커밋 메시지 본문 규칙

- 무엇을(What) 변경했는지 명시
- 왜(Why) 변경했는지 설명
- 한 커밋에 한 가지 목적의 변경만 포함

## 9.4 커밋 메시지 예시

```
[feat] 배너 에디터 이미지 업로드 기능 추가

- 드래그 앤 드롭 이미지 업로드 구현
- 이미지 미리보기 기능 추가
- 파일 크기 및 형식 검증 로직 추가
```

## 9.5 브랜치 전략 (참고용)

- main/master: 배포 가능한 안정 버전만
- develop: 개발 통합 브랜치
- feature/기능명: 기능 개발
- fix/버그명: 버그 수정
- hotfix/긴급수정: 긴급 수정

# ============================================================================

# 📌 섹션 10: UI/UX 규칙 (프론트엔드)

# ============================================================================

## 10.1 사용자 피드백 규칙

- 모든 사용자 액션에 즉각적 피드백 제공 (300ms 이내)
- 로딩 상태 표시 필수 (스피너, 스켈레톤, 프로그레스바)
- 성공/실패 결과 명확히 표시 (토스트, 알림)
- 에러 발생 시 복구 방법 안내

## 10.2 인터랙션 규칙

- 클릭 가능한 요소는 시각적으로 구분 (hover 효과)
- 버튼 중복 클릭 방지 (로딩 중 비활성화)
- 폼 제출 후 중복 제출 방지
- 위험한 작업(삭제 등)은 확인 절차 추가

## 10.3 반응형 및 접근성

- 키보드만으로 모든 기능 사용 가능
- 포커스 상태 시각적 표시 필수
- 적절한 색상 대비 (WCAG 4.5:1 이상)
- 스크린 리더 호환성 확보 (ARIA 적용)

## 10.4 상태 표시

- 비어있는 상태(Empty State) 안내 메시지 제공
- 오프라인 상태 감지 및 표시
- 데이터 로딩 실패 시 재시도 옵션 제공

# ============================================================================

# 📌 섹션 11: 로깅 및 모니터링 (Logging & Monitoring)

# ============================================================================

## 11.1 로깅 레벨 표준

- **DEBUG**: 개발 시 디버깅용 상세 정보 (배포 환경 비활성화)
- **INFO**: 주요 비즈니스 로직 진행 정보
- **WARN**: 잠재적 문제 상황 (정상 동작은 함)
- **ERROR**: 에러 발생 (복구 가능/불가능 모두)

## 11.2 로그 포맷 표준

- 형식: `[시간][레벨][위치] 메시지`
- 예시: `[2025-11-26 10:30:45][ERROR][BannerEditor.save] 이미지 업로드 실패: 파일 크기 초과`

## 11.3 로깅 규칙

- 중요 비즈니스 로직 진입/완료 로그 필수
- 에러 발생 시 상세 컨텍스트 포함 (입력값, 상태 등)
- 민감 정보(비밀번호, 토큰 등) 로그 출력 금지

## 11.4 배포 환경 규칙

- DEBUG 레벨 로그 비활성화
- console.log 제거 또는 비활성화
- console.error는 유지 가능

# ============================================================================

# 📌 섹션 12: 문서화 규칙 (Documentation)

# ============================================================================

## 12.1 코드 문서화

- 공개 API/함수는 반드시 문서화 (JSDoc, JavaDoc 등)
- 복잡한 알고리즘은 의도와 동작 방식 설명
- 비즈니스 로직의 "왜(Why)"를 설명하는 주석 작성
- 임시 코드는 TODO/FIXME 주석에 담당자, 기한 명시

## 12.2 주석 작성 원칙

- 코드가 "무엇을" 하는지보다 "왜" 그렇게 하는지 설명
- 자명한 코드에 불필요한 주석 작성 금지
- 주석은 코드 변경 시 함께 업데이트

## 12.3 TODO/FIXME 형식

- 형식: `// TODO: [담당자] 내용 (기한: YYYY-MM-DD)`
- 예시: `// TODO: [홍길동] 에러 처리 로직 개선 필요 (기한: 2025-12-01)`

## 12.4 프로젝트 문서화

- README: 프로젝트 개요, 설치 방법, 실행 방법
- CHANGELOG: 버전별 변경 사항
- 아키텍처 문서: 시스템 구조, 주요 모듈 설명

# ============================================================================

# 📌 섹션 13: 프로젝트 디렉토리 구조 규칙 (Directory Structure)

# ============================================================================

## 13.1 디렉토리 네이밍 규칙

- 폴더명은 소문자 사용 (lowercase)
- 단어 구분은 케밥케이스(kebab-case) 또는 언더스코어(\_) 사용
- 의미 있는 명확한 이름 사용 (축약어 지양)
- 복수형 사용 권장 (components, modules, utils, assets)

## 13.2 기능별 분리 원칙

- 기능(Feature) 단위로 디렉토리 분리
- 관련 파일들을 같은 디렉토리에 그룹화
- 순환 의존성 방지를 위한 계층 구조 설계
- 공통 모듈은 common 또는 shared 디렉토리에 배치

## 13.3 표준 디렉토리 구조 (참고)

```
/src 또는 /app     : 소스 코드 루트
  /assets          : 정적 자원 (이미지, 폰트, 아이콘)
  /components      : 재사용 가능한 UI 컴포넌트
  /modules         : 기능별 모듈
  /common (shared) : 공통 유틸리티, 헬퍼
  /config          : 설정 파일
  /constants       : 상수 정의
  /styles          : 전역 스타일
  /types           : 타입 정의 (TypeScript)
/docs              : 문서
/tests             : 테스트 코드
```

## 13.4 깊이 제한 규칙

- 디렉토리 깊이는 4~5단계 이내 권장
- 너무 깊은 중첩은 경로 관리 어려움 유발
- 필요시 alias(경로 별칭) 설정 활용

## 13.5 파일 배치 규칙

- index 파일로 모듈 진입점 명시 (index.js, index.ts)
- 테스트 파일: 소스 파일과 같은 위치 또는 **tests** 폴더
- 타입 정의 파일: 소스 파일과 같은 위치 또는 types 폴더
- README는 각 주요 디렉토리에 배치 권장

## 13.6 디렉토리 금지 사항

- 루트 디렉토리에 소스 파일 직접 배치 금지
- 의미 없는 폴더명 사용 금지 (misc, stuff, temp, test1)
- 빈 디렉토리 커밋 금지 (.gitkeep 사용 시 제외)
- 동일 기능의 파일이 여러 위치에 분산 배치 금지

# ============================================================================

# 📌 섹션 14: 모듈 분할 규칙 (Module Split Rules)

# ============================================================================

## 14.1 파일 크기 기준 (CRITICAL!)

- ⚠️ **단일 파일 500줄 초과 시 모듈 분할 필수**
- 300줄 초과 시 분할 검토 권장
- 1000줄 초과 파일은 즉시 분할 대상

## 14.2 모듈 분할 트리거 조건

- 파일 라인수 500줄 초과
- 서로 다른 책임을 가진 함수들이 한 파일에 혼재
- 테스트 작성이 어려울 정도로 복잡한 구조
- 코드 리뷰 시 파일 전체 파악이 어려운 경우

## 14.3 분할 방법: 서브 디렉토리 패턴

- 원본 파일명으로 서브 디렉토리 생성
- 기능/책임별로 파일 분리
- index.js로 통합 진입점 제공
- 예시 구조:

  ```
  [분할 전]
  /modules/banners/editor.js (800줄)

  [분할 후]
  /modules/banners/editor/
    ├── index.js       # 통합 진입점 (export)
    ├── core.js        # 핵심 로직
    ├── ui.js          # UI 관련 기능
    ├── data.js        # 데이터 처리
    ├── events.js      # 이벤트 핸들러
    └── utils.js       # 유틸리티 함수
  ```

## 14.4 분할 기준 (책임 분리)

- **core**: 핵심 비즈니스 로직, 초기화
- **ui**: DOM 조작, 렌더링, UI 상태 관리
- **data**: 데이터 fetching, 가공, 저장
- **events**: 이벤트 바인딩, 핸들러
- **utils**: 헬퍼 함수, 유틸리티
- **constants**: 상수, 설정값
- **types**: 타입 정의 (TypeScript)

## 14.5 분할 시 필수 사항

- 각 분할 파일에 JSDoc 헤더 작성
- index.js에서 public API만 export
- 모듈 간 의존성 최소화 (단방향 의존성 유지)
- 순환 참조(Circular Dependency) 절대 금지
- 분할 후에도 기존 기능 100% 동작 보장

## 14.6 index.js 작성 규칙

```javascript
/**
 * @fileoverview 모듈명 - 통합 진입점
 * @description 분할된 모듈들을 통합하여 외부에 제공
 */

// 서브 모듈 import
import { Core } from "./core.js";
import { UI } from "./ui.js";
import { Data } from "./data.js";

// 통합 객체 또는 개별 export
export const ModuleName = {
  ...Core,
  ...UI,
  ...Data,
};

// 또는 개별 export
export { Core, UI, Data };
```

## 14.7 분할 시 금지 사항

- 기존 public API 시그니처 변경 금지
- 분할만을 위한 불필요한 추상화 금지
- 한 파일에 한 가지 책임만 (분할 후에도 SRP 준수)
- 분할 파일 간 과도한 의존성 금지

## 14.8 분할 체크리스트

- [ ] 분할 후 모든 기존 기능 정상 동작 확인
- [ ] 분할된 각 파일 라인수 300줄 이내
- [ ] 순환 참조 없음 확인
- [ ] index.js 통합 진입점 정상 작동
- [ ] JSDoc 및 주석 업데이트 완료
- [ ] 기존 호출 코드 영향 없음 확인

# ============================================================================

# 📌 섹션 15: 코드 복잡도 관리 규칙 (Complexity Management)

# ============================================================================

## 15.1 순환 복잡도 제한 (Cyclomatic Complexity)

- 함수당 순환 복잡도 10 이하 유지 필수
- 15 초과 시 즉시 함수 분할
- if/else, switch, 반복문, 삼항연산자가 복잡도 증가 요인
- 복잡한 조건은 의미 있는 함수로 추출

## 15.2 중첩 깊이 제한 (Nesting Depth)

- 중첩 깊이 최대 3단계 이내 (권장 2단계)
- 4단계 이상 중첩 시 Early Return 또는 함수 추출
- 예시:

  ```
  [나쁜 예]
  if (a) {
    if (b) {
      if (c) {
        if (d) { ... }  // 4단계 중첩 ❌
      }
    }
  }

  [좋은 예]
  if (!a) return;
  if (!b) return;
  if (!c) return;
  if (d) { ... }  // Early Return ✅
  ```

## 15.3 함수 파라미터 제한

- 함수 파라미터 최대 4개 이내 권장
- 5개 이상 시 객체로 묶어서 전달
- Boolean 파라미터 지양 (의미 파악 어려움)
- 예시:

  ```
  [나쁜 예]
  function createUser(name, age, email, phone, address, isAdmin) { }

  [좋은 예]
  function createUser(userData) { }
  function createUser({ name, age, email, phone, address, isAdmin }) { }
  ```

## 15.4 함수 길이 제한

- 함수당 30줄 이내 권장 (50줄 초과 금지)
- 한 화면에서 전체 로직 파악 가능해야 함
- 길어지면 서브 함수로 추출

## 15.5 조건문 복잡도 관리

- 복잡한 조건식은 의미 있는 변수/함수로 추출
- 예시:

  ```
  [나쁜 예]
  if (user.age >= 19 && user.status === 1 && !user.isBanned && user.email) { }

  [좋은 예]
  const isEligibleUser = user.isAdult() && user.isActive() && user.hasValidEmail();
  if (isEligibleUser) { }
  ```

# ============================================================================

# 📌 섹션 16: 코드 냄새 감지 및 금지 규칙 (Code Smell Prevention)

# ============================================================================

## 16.1 절대 금지 안티패턴 (Critical Anti-patterns)

- **God Object/Function**: 하나의 객체/함수가 너무 많은 책임을 가짐
- **Spaghetti Code**: 구조 없이 얽힌 코드, 점프/분기가 복잡
- **Copy-Paste Programming**: 복사-붙여넣기 코딩
- **Magic Numbers/Strings**: 의미 없는 숫자/문자열 직접 사용
- **Dead Code**: 사용되지 않는 코드 방치
- **Feature Envy**: 다른 모듈의 데이터를 과도하게 사용
- **Premature Optimization**: 필요 없는 조기 최적화

## 16.2 경고 신호 (Warning Signs) - 발견 시 리팩토링 검토

- 함수명에 And/Or 포함 → 단일 책임 위반 가능성
- 주석 없이는 이해 불가한 코드 → 가독성 문제
- 같은 조건문이 여러 곳에 반복 → 추상화 필요
- 긴 파라미터 목록 → 객체화 필요
- 과도한 전역 변수 사용 → 상태 관리 문제
- 긴 메서드 체인 → 디미터 법칙 위반 가능성
- 빈번한 타입 체크 → 다형성 활용 검토

## 16.3 Magic Number/String 금지

- 모든 숫자/문자열 리터럴은 상수로 정의
- 상수명은 의미를 명확히 표현
- 예시:

  ```
  [나쁜 예]
  if (status === 1) { }
  setTimeout(fn, 3000);
  element.style.width = '1200px';

  [좋은 예]
  const STATUS_ACTIVE = 1;
  const ANIMATION_DELAY_MS = 3000;
  const CONTAINER_MAX_WIDTH = '1200px';

  if (status === STATUS_ACTIVE) { }
  setTimeout(fn, ANIMATION_DELAY_MS);
  element.style.width = CONTAINER_MAX_WIDTH;
  ```

## 16.4 Dead Code 관리

- 사용되지 않는 코드 즉시 삭제
- "나중에 쓸 것 같아서" 주석 처리 금지
- Git 히스토리로 복원 가능하므로 과감히 삭제
- 주석 처리된 코드 블록 커밋 금지

## 16.5 중복 코드 (Duplication) 제거

- 동일 코드 2회 반복 → 함수 추출 검토
- 동일 코드 3회 이상 반복 → 함수 추출 필수
- 유사 코드(50% 이상)도 공통 로직 추출 검토

# ============================================================================

# 📌 섹션 17: 의존성 관리 규칙 (Dependency Management)

# ============================================================================

## 17.1 결합도 최소화 원칙

- 모듈 간 의존성은 인터페이스를 통해서만
- 구체적인 구현체가 아닌 추상화에 의존
- 순환 의존성(Circular Dependency) 절대 금지
- 의존하는 모듈의 내부 구현에 의존 금지

## 17.2 의존성 방향 규칙

- 의존성은 항상 단방향으로 유지
- 상위 모듈 → 하위 모듈 방향만 허용
- 계층 구조 예시:

  ```
  [허용]
  UI Layer → Business Layer → Data Layer

  [금지]
  Data Layer → Business Layer (역방향)
  UI Layer ↔ Data Layer (직접 의존)
  ```

## 17.3 외부 라이브러리 사용 규칙

- 라이브러리 도입 전 필요성 검토 필수
- 직접 구현 가능한 간단한 기능은 라이브러리 미사용
- 라이브러리 버전 명시적 고정 (^, ~ 사용 주의)
- 래퍼(Wrapper) 레이어를 통한 격리 권장
- 더 이상 유지보수되지 않는 라이브러리 사용 금지

## 17.4 의존성 주입 (DI) 원칙

- 외부 의존성(API, 설정, 서비스)은 주입 가능하도록 설계
- 하드코딩된 의존성 금지
- 테스트 시 Mock 주입 가능한 구조
- 예시:

  ```
  [나쁜 예]
  function fetchUsers() {
    return axios.get('/api/users');  // axios에 직접 의존
  }

  [좋은 예]
  function fetchUsers(httpClient = axios) {
    return httpClient.get('/api/users');  // 주입 가능
  }
  ```

## 17.5 응집도 높이기

- 관련 기능은 같은 모듈에 배치
- 모듈 내부의 요소들은 서로 밀접하게 연관
- 낮은 결합도 + 높은 응집도 = 이상적인 모듈 설계

# ============================================================================

# 📌 섹션 18: 인터페이스 계약 규칙 (Interface Contract)

# ============================================================================

## 18.1 함수 계약 (Function Contract)

- 함수의 입력/출력을 명확히 정의하고 문서화
- 사전 조건(Precondition): 함수 호출 전 만족해야 할 조건
- 사후 조건(Postcondition): 함수 실행 후 보장되는 상태
- 불변 조건(Invariant): 항상 유지되어야 할 조건

## 18.2 반환값 일관성

- null/undefined 대신 빈 배열, 빈 객체 반환 선호
- 에러 상황에서도 일관된 형태 반환
- 예상 가능한 반환 타입 유지
- 예시:

  ```
  [나쁜 예]
  function getUsers() {
    if (error) return null;      // null 반환
    if (empty) return undefined; // undefined 반환
    return users;                // 배열 반환
  }

  [좋은 예]
  function getUsers() {
    if (error) return [];  // 빈 배열 (일관성)
    if (empty) return [];  // 빈 배열 (일관성)
    return users;          // 배열
  }
  ```

## 18.3 API 버전 호환성

- 기존 public API 시그니처 변경 금지
- 기능 추가는 선택적 파라미터 또는 새 함수로
- 삭제 시 Deprecation 경고 후 충분한 유예기간
- Breaking Change는 메이저 버전 업데이트 시에만

## 18.4 이벤트/콜백 계약

- 콜백 함수의 파라미터 순서 일관성 유지
- 이벤트 객체 구조 표준화
- Node.js 스타일 권장: callback(error, data)
- 에러 우선 콜백 패턴 일관 적용

## 18.5 옵션 객체 패턴

- 선택적 설정이 많은 경우 옵션 객체 사용
- 기본값 명시적 정의
- 예시:
  ```
  function createModal(options = {}) {
    const {
      title = '알림',
      closable = true,
      width = 500,
      onClose = null
    } = options;
    // ...
  }
  ```

# ============================================================================

# 📌 섹션 19: 상태 관리 규칙 (State Management)

# ============================================================================

## 19.1 상태 불변성 (Immutability) 권장

- 상태 직접 변경(mutation) 지양
- 새로운 상태 객체 생성하여 반환
- 배열/객체 조작 시 spread 연산자 또는 불변 메서드 사용
- 예시:

  ```
  [나쁜 예]
  state.items.push(newItem);
  state.user.name = 'New Name';

  [좋은 예]
  const newItems = [...state.items, newItem];
  const newUser = { ...state.user, name: 'New Name' };
  ```

## 19.2 상태 범위 최소화

- 전역 상태 사용 최소화
- 상태는 필요한 범위에서만 접근 가능하도록
- 컴포넌트/모듈 로컬 상태 우선
- 전역 상태가 필요한 경우 명확한 이유 문서화

## 19.3 단일 진실 공급원 (Single Source of Truth)

- 동일한 데이터는 한 곳에서만 관리
- 데이터 중복 저장 금지
- 파생 데이터는 원본에서 계산으로 획득
- 캐시 데이터도 원본과 동기화 전략 명확히

## 19.4 상태 변경 추적 가능성

- 상태 변경은 명시적인 함수를 통해서만
- 어디서 왜 변경되었는지 추적 가능해야 함
- 직접적인 상태 조작 금지
- 상태 변경 함수는 의도를 드러내는 이름 사용

## 19.5 비동기 상태 관리

- 로딩/성공/실패 상태 명확히 구분
- 이전 요청 결과가 현재 상태를 덮어쓰지 않도록 주의
- Race Condition 방지 로직 필수

# ============================================================================

# 📌 섹션 20: 기술 부채 관리 규칙 (Technical Debt Management)

# ============================================================================

## 20.1 기술 부채 식별 마커

- **TODO**: 추후 구현 필요 (기능 미완성)
- **FIXME**: 버그 또는 문제 있는 코드
- **HACK**: 임시 해결책 (리팩토링 필요)
- **OPTIMIZE**: 성능 개선 필요
- **REVIEW**: 코드 리뷰 필요
- 형식: `// TODO: [담당자] 설명 (기한: YYYY-MM-DD)`

## 20.2 부채 허용 기준

- 임시 코드는 반드시 기한 명시
- 기한 없는 TODO/FIXME 금지
- 2주 이상 방치된 부채는 즉시 처리 또는 이슈 등록
- 긴급 배포 시 발생한 부채는 다음 스프린트에서 최우선 처리

## 20.3 부채 상환 원칙

- **보이스카웃 규칙**: 코드를 발견한 것보다 깨끗하게 남기기
- 기능 추가 시 주변 부채 함께 처리
- 스프린트당 부채 상환 시간 확보 (권장 10~20%)
- 부채 목록 정기적 리뷰 (주 1회 권장)

## 20.4 부채 발생 방지

- 일정 압박으로 인한 품질 타협 최소화
- "나중에 고치자" 마인드 경계
- 처음부터 제대로 (Do It Right The First Time)
- 코드 리뷰에서 부채 발생 가능성 체크

## 20.5 부채 우선순위

- **Critical**: 보안, 데이터 무결성 관련 → 즉시 수정
- **High**: 버그 유발 가능성 높음 → 1주 이내 수정
- **Medium**: 유지보수 어려움 → 2주 이내 수정
- **Low**: 코드 스타일, 미미한 개선 → 여유 시 수정

# ============================================================================

# 📌 섹션 21: 확장성 설계 규칙 (Extensibility Design)

# ============================================================================

## 21.1 Open/Closed 원칙 적용

- 기존 코드 수정 없이 기능 확장 가능한 구조
- if/else, switch 대신 전략 패턴, 플러그인 패턴 고려
- 설정/옵션으로 동작 변경 가능하도록 설계
- 예시:

  ```
  [나쁜 예 - 새 타입 추가 시 함수 수정 필요]
  function process(type) {
    if (type === 'A') { ... }
    else if (type === 'B') { ... }
    // 새 타입 추가 시 여기에 else if 추가 필요
  }

  [좋은 예 - 새 타입 추가 시 핸들러만 등록]
  const handlers = { A: handlerA, B: handlerB };
  function process(type) {
    return handlers[type]();
  }
  // 새 타입 추가: handlers.C = handlerC;
  ```

## 21.2 설정 분리 원칙

- 하드코딩된 값은 설정으로 분리
- 환경별(dev/staging/prod) 설정 분리
- 설정 변경으로 동작 변경 가능하도록
- 코드 변경 없이 설정만으로 조정 가능한 항목 최대화

## 21.3 플러그인/모듈 패턴

- 핵심 기능과 확장 기능 분리
- 확장 포인트(Extension Point) 명확히 정의
- 새 기능 추가 시 기존 코드 영향 최소화
- 플러그인 인터페이스 표준화

## 21.4 변경 영향 최소화

- 변경 시 영향 범위 예측 가능해야 함
- 파급 효과(Ripple Effect) 최소화 설계
- 모듈 간 느슨한 결합 유지
- 인터페이스 변경은 최소한으로

## 21.5 미래 대비 설계 (단, YAGNI 준수)

- 명확히 예상되는 확장만 고려
- 과도한 추상화 금지
- 현재 요구사항을 만족하면서 확장 여지 남기기
- "혹시 나중에"를 위한 코드 금지

# ============================================================================

# 📌 섹션 22: 자기 문서화 코드 규칙 (Self-Documenting Code)

# ============================================================================

## 22.1 코드 자체가 문서

- 코드를 읽으면 의도가 파악되어야 함
- 주석 없이도 이해 가능한 코드 작성
- 복잡한 로직은 의미 있는 함수명으로 추출
- "코드가 무엇을 하는지"가 명확해야 함

## 22.2 의도를 드러내는 코드

- "어떻게(How)" 보다 "무엇을(What)" 표현
- 구현 세부사항 숨기고 의도 드러내기
- 예시:

  ```
  [나쁜 예 - 구현 세부사항 노출]
  if (user.age >= 19 && user.status === 1 && !user.isBanned) { }

  [좋은 예 - 의도 표현]
  if (user.canAccessAdultContent()) { }
  ```

## 22.3 부정문 최소화

- 이중 부정 금지: `!isNotValid` → `isValid`
- 긍정적 조건 우선 사용
- 부정 조건은 변수로 추출하여 의미 부여
- 예시:

  ```
  [나쁜 예]
  if (!isNotLoggedIn && !hasNoPermission) { }

  [좋은 예]
  if (isLoggedIn && hasPermission) { }
  ```

## 22.4 일관된 추상화 수준

- 한 함수 내 추상화 수준 통일
- 고수준 로직과 저수준 로직 혼재 금지
- 추상화 수준이 다르면 함수 분리
- 예시:

  ```
  [나쁜 예 - 추상화 수준 혼재]
  function processOrder(order) {
    validateOrder(order);                    // 고수준
    const tax = order.total * 0.1;           // 저수준 계산
    sendConfirmationEmail(order);            // 고수준
    db.query('INSERT INTO orders...');       // 저수준 DB 접근
  }

  [좋은 예 - 일관된 추상화 수준]
  function processOrder(order) {
    validateOrder(order);
    calculateTax(order);
    saveOrder(order);
    notifyCustomer(order);
  }
  ```

## 22.5 명확한 흐름

- 코드 실행 흐름이 한눈에 파악되어야 함
- 숨겨진 분기, 예상치 못한 점프 금지
- 조건부 로직은 명시적으로 표현
- 암묵적인 동작 금지 (모든 동작은 명시적으로)

# ============================================================================

# 📌 섹션 23: 코드 관계 무결성 규칙 (Code Relationship Integrity)

# ============================================================================

## 23.1 코드 수정 시 영향도 분석 필수 (CRITICAL!)

- ⚠️ **코드 수정 전 JSDoc 내 연관 파일 태그 반드시 확인**
- 확인해야 할 JSDoc 태그:
  - `@requires` - 이 파일이 의존하는 모듈 (변경 시 영향 받음)
  - `@see` - 관련/참조 모듈 (동기화 필요 가능성)
  - `@architecture` - 아키텍처 구조 내 위치 및 관계
  - `@fires` - 이 모듈이 발생시키는 이벤트
  - `@listens` - 이 모듈이 수신하는 이벤트
  - `@memberof` - 소속 모듈/그룹
- 연관된 모든 파일의 영향도를 사전에 파악

## 23.2 수정 유형별 동기화 필수 항목

### 23.2.1 함수/메서드 수정 시

- 함수 시그니처(파라미터, 반환값) 변경 → 호출하는 모든 파일 확인 필수
- 함수 삭제 → 사용처 모두 확인 및 대체 방안 마련
- 함수명 변경 → 전체 프로젝트 검색으로 사용처 확인

### 23.2.2 상수/설정값 수정 시

- 상수값 변경 → 해당 상수를 사용하는 모든 파일 영향도 확인
- 상수명 변경 → 전체 프로젝트 검색으로 사용처 확인
- 상수 삭제 → 사용처 없음 확인 후 삭제

### 23.2.3 이벤트 기반 통신 수정 시

- 이벤트명 변경 → 발신(@fires) 및 수신(@listens) 모든 파일 확인
- 이벤트 데이터 구조 변경 → 수신 측 처리 로직 확인
- 이벤트 삭제 → 수신 측 대응 처리 확인

### 23.2.4 모듈 구조 변경 시

- 파일 위치 변경 → import/require 경로 전체 수정
- 모듈 분할/병합 → @architecture, @structure 태그 업데이트
- export 변경 → import하는 모든 파일 확인

## 23.3 연관 파일 영향도 체크리스트 (수정 전 필수 확인!)

### 23.3.1 하위 방향 체크 (이 파일이 의존하는 것)

- [ ] `@requires`에 명시된 모듈의 변경사항이 이 파일에 영향 주는지 확인
- [ ] import/require하는 모듈의 API 변경 여부 확인

### 23.3.2 상위 방향 체크 (이 파일을 의존하는 것)

- [ ] 이 파일을 `@requires`로 참조하는 파일들 검색 및 확인
- [ ] 이 파일의 함수를 호출하는 모든 파일 확인
- [ ] 이 파일의 상수/설정을 사용하는 모든 파일 확인

### 23.3.3 수평 방향 체크 (관련된 것)

- [ ] `@see`에 명시된 관련 모듈과의 동기화 확인
- [ ] 이벤트로 통신하는 파일들 (@fires ↔ @listens) 확인
- [ ] 공유 상태를 사용하는 다른 모듈 확인

## 23.4 무결성 검증 규칙

### 23.4.1 의존성 무결성

- 순환 참조(Circular Dependency) 발생 여부 검증 필수
- 누락된 의존성 없는지 확인 (@requires 태그 완전성)
- 사용되지 않는 의존성 정리 (Dead Import 제거)

### 23.4.2 인터페이스 무결성

- 함수 시그니처 변경 시 모든 호출처 일괄 수정
- 반환값 타입/구조 변경 시 사용처 처리 로직 확인
- 옵션 객체 구조 변경 시 기본값 처리 확인

### 23.4.3 이벤트 무결성

- 이벤트 발신처와 수신처 1:N 관계 문서화
- 이벤트 데이터 스키마 일관성 유지
- 이벤트 생명주기 (등록/해제) 완전성 확인

### 23.4.4 상태 무결성

- 공유 상태 변경 시 모든 사용처 영향 분석
- 상태 초기화/정리 로직 완전성 확인
- 상태 변경 순서에 따른 사이드 이펙트 확인

## 23.5 코드 관계 문서화 규칙

### 23.5.1 의존성 명시 규칙

```javascript
/**
 * @requires ModuleA - 사용자 인증 처리
 * @requires ModuleB - API 통신 처리
 * @requires ../common/utils - 유틸리티 함수
 */
```

### 23.5.2 역방향 참조 명시 (선택적이지만 권장)

```javascript
/**
 * @usedby ModuleX - 메인 페이지에서 호출
 * @usedby ModuleY - 설정 페이지에서 호출
 */
```

### 23.5.3 이벤트 관계 명시

```javascript
/**
 * @fires banner:updated - 배너 수정 완료 시 발생
 * @fires banner:deleted - 배너 삭제 완료 시 발생
 * @listens modal:opened - 모달 열림 이벤트 수신
 */
```

## 23.6 수정 완료 후 검증 체크리스트

- [ ] 수정된 파일의 JSDoc 업데이트 완료
- [ ] @requires 목록 최신화 완료
- [ ] @see 관련 모듈 동기화 완료
- [ ] 연관 파일들의 JSDoc에 변경사항 반영 (필요시)
- [ ] 순환 참조 없음 확인
- [ ] 모든 호출처 정상 동작 확인
- [ ] 이벤트 발신/수신 정상 동작 확인

## 23.7 영향도 분석 보고 형식

수정 작업 시 다음 형식으로 영향도를 보고:

```
📋 영향도 분석 결과
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

📄 수정 대상: [파일명]
📝 수정 내용: [수정 내용 요약]

🔗 연관 파일 분석:
├─ 의존하는 모듈 (@requires): [목록]
├─ 이 파일을 사용하는 모듈: [목록]
├─ 관련 모듈 (@see): [목록]
└─ 이벤트 연결 모듈: [목록]

⚠️ 영향받는 파일:
├─ [파일1]: [영향 내용]
├─ [파일2]: [영향 내용]
└─ [파일3]: [영향 내용]

✅ 조치 사항:
├─ [조치1]
├─ [조치2]
└─ [조치3]
```

## 23.8 나비효과 방지 - A to Z 완전 연계성 확인 (CRITICAL!)

### 23.8.1 나비효과 방지 원칙

- 🦋 **"작은 변경 하나가 전체 시스템에 예상치 못한 치명적 영향을 줄 수 있다"**
- ⚠️ **모든 수정은 연쇄적 영향을 끝(최종 사용처)까지 추적해야 함**
- ❌ **"이 정도는 괜찮겠지", "여기까지만 확인하면 되겠지" 판단 절대 금지!**
- 영향도가 불확실하면 확인될 때까지 끝까지 추적
- 추적 중단 = 잠재적 버그 방치 = 프로덕트 품질 저하

### 23.8.2 A to Z 연쇄 영향 추적 의무화 (필수!)

모든 코드 수정 시 다음 단계를 **끝까지** 추적:

```
[수정 파일]
    │
    ▼
[1차 영향권] ─── 수정 파일을 직접 호출/참조하는 파일들
    │
    ▼
[2차 영향권] ─── 1차 파일들을 호출/참조하는 파일들
    │
    ▼
[3차 영향권] ─── 2차 파일들을 호출/참조하는 파일들
    │
    ▼
[N차 영향권] ─── ... 계속 추적 ...
    │
    ▼
[최종 사용처] ─── UI 화면, API 엔드포인트, 사용자 인터페이스
                  (더 이상 참조하는 곳이 없을 때까지!)
```

### 23.8.3 연쇄 영향 추적 단계별 체크리스트

**📍 1단계: 직접 영향권 (1차)**

- [ ] 수정 파일의 함수를 직접 호출하는 파일 모두 식별
- [ ] 수정 파일의 상수/변수를 사용하는 파일 모두 식별
- [ ] 수정 파일의 이벤트를 수신하는 파일 모두 식별
- [ ] 1차 영향권 파일 목록 작성 완료

**📍 2단계: 간접 영향권 (2차)**

- [ ] 1차 영향권 각 파일을 호출하는 파일 모두 식별
- [ ] 1차 영향권 파일들의 반환값/상태를 사용하는 파일 식별
- [ ] 2차 영향권 파일 목록 작성 완료

**📍 3단계 ~ N단계: 파급 영향권**

- [ ] 이전 단계 파일들을 참조하는 파일 계속 추적
- [ ] 새로운 영향권 파일이 발견되지 않을 때까지 반복
- [ ] 각 단계별 영향권 파일 목록 작성

**📍 최종 단계: 종착점 확인**

- [ ] 최종 사용처(UI/API/사용자 인터페이스) 도달 확인
- [ ] 더 이상 참조하는 파일이 없음 확인
- [ ] 전체 영향 경로 문서화 완료

### 23.8.4 영향 전파 경로 시각화 (필수 작성!)

모든 수정 작업 시 다음 형식으로 영향 경로를 시각화:

```
🦋 나비효과 영향 경로 분석
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

📄 수정 파일: [파일명]
📝 수정 내용: [변경 사항]

🔗 영향 전파 경로:

[수정] module/editor/core.js
         │
         ├─→ [1차] module/editor/ui.js
         │         │
         │         ├─→ [2차] module/editor/index.js
         │         │         │
         │         │         └─→ [3차] pages/editor.jsp (최종: UI 화면)
         │         │
         │         └─→ [2차] module/editor/events.js
         │                   │
         │                   └─→ [3차] module/modal/handler.js
         │                             │
         │                             └─→ [4차] common/modalHelper.js (최종)
         │
         └─→ [1차] module/editor/data.js
                   │
                   └─→ [2차] api/editorAPI.js (최종: API 엔드포인트)

📊 영향 요약:
├─ 총 영향 파일 수: [N]개
├─ 최대 전파 깊이: [N]단계
├─ 최종 사용처: [목록]
└─ 위험도: [높음/중간/낮음]

✅ 각 파일별 필요 조치:
├─ [파일1]: [조치 내용]
├─ [파일2]: [조치 내용]
└─ [파일N]: [조치 내용]
```

### 23.8.5 추적 중단 금지 규칙

다음 상황에서도 추적을 중단하지 말 것:

- ❌ "이 파일은 별로 중요하지 않아 보여서" → 끝까지 확인!
- ❌ "여기서부터는 영향 없을 것 같아서" → 확인 전까지 가정 금지!
- ❌ "시간이 없어서" → 불완전한 분석은 더 큰 문제 유발!
- ❌ "너무 많은 파일이 연결되어 있어서" → 모두 확인해야 함!
- ❌ "이전에도 문제없었으니까" → 과거와 현재는 다름!

### 23.8.6 영향도 분석 완료 기준

다음 조건을 **모두** 만족해야 분석 완료:

- [ ] 모든 영향 경로가 최종 사용처까지 추적됨
- [ ] 각 경로의 모든 파일이 식별됨
- [ ] 누락된 연결고리가 없음이 확인됨
- [ ] 영향 전파 경로가 시각화됨
- [ ] 각 파일별 필요 조치가 정의됨
- [ ] 위험도 평가가 완료됨

### 23.8.7 나비효과 위험도 평가 기준

| 위험도      | 기준                                          | 대응                            |
| ----------- | --------------------------------------------- | ------------------------------- |
| 🔴 **높음** | 최종 사용처가 3개 이상 / 전파 깊이 4단계 이상 | 신중한 검토 필수, 단계별 테스트 |
| 🟡 **중간** | 최종 사용처가 2개 / 전파 깊이 3단계           | 영향 파일 모두 확인 후 진행     |
| 🟢 **낮음** | 최종 사용처가 1개 / 전파 깊이 2단계 이하      | 기본 확인 후 진행               |

# ============================================================================

# ⚠️ 글로벌 규칙 적용 안내

# ============================================================================

#

# 이 문서는 모든 프로젝트에 범용적으로 적용 가능한 규칙입니다.

# 프로젝트별 특수 규칙은 .cursorrules 파일에 별도로 정의하세요.

#

# 규칙 우선순위:

# 1. 프로젝트별 규칙 (.cursorrules)

# 2. 글로벌 규칙 (이 문서)

#

# 두 규칙이 충돌할 경우 프로젝트별 규칙을 우선 적용합니다.

#

# ============================================================================
